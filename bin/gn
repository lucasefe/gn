#!/usr/bin/env ruby

# This tool includes embedded code from other projects, and their respective
# copyright notes have been included.

require "tempfile"
require "fileutils"

# Mote -- https://github.com/soveran/mote
#
# Copyright (c) 2011-2015 Michel Martens
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
class Mote
  VERSION = "1.1.4"

  PATTERN = /^[^\S\n]*(%)[^\S\n]*(.*?)(?:\n|\Z)|(<\?)\s+(.*?)\s+\?>|(\{\{)(.*?)\}\}/m

  def self.parse(template, context = self, vars = [])
    terms = template.split(PATTERN)

    parts = "Proc.new do |params, __o|\n params ||= {}; __o ||= ''\n"

    vars.each do |var|
      parts << "%s = params[%p]\n" % [var, var]
    end

    while (term = terms.shift)
      case term
      when "<?" then parts << "#{terms.shift}\n"
      when "%"  then parts << "#{terms.shift}\n"
      when "{{" then parts << "__o << (#{terms.shift}).to_s\n"
      else           parts << "__o << #{term.dump}\n"
      end
    end

    parts << "__o; end"

    compile(context, parts)
  end

  def self.compile(context, parts)
    context.instance_eval(parts)
  end

  module Helpers
    def mote(file, params = {}, context = self)
      mote_cache[file] ||= Mote.parse(File.read(file), context, params.keys)
      mote_cache[file][params]
    end

    def mote_cache
      Thread.current[:_mote_cache] ||= {}
    end
  end
end

# Clap -- https://github.com/soveran/clap
#
# Copyright (c) 2010 Michel Martens
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
class Clap
  attr :argv
  attr :opts

  def self.run(args, opts)
    new(args, opts).run
  end

  def initialize(argv, opts)
    @argv = argv.dup
    @opts = opts
  end

  def run
    args = []

    while argv.any?

      item = argv.shift
      flag = opts[item]

      if flag

        # Work around lambda semantics in 1.8.7.
        arity = [flag.arity, 0].max

        # Raise if there are not enough parameters
        # available for the flag.
        if argv.size < arity
          raise ArgumentError
        end

        # Call the lambda with N items from argv,
        # where N is the lambda's arity.
        flag.call(*argv.shift(arity))
      else

        # Collect the items that don't correspond to
        # flags.
        args << item
      end
    end

    args
  end
end

# Gn -- Copyright (c) 2012 Leandro LÃ³pez, Michel Martens and Lucas Florio.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE
class Gn
  class Blueprint
    def initialize(parent, constant)
      @parent   = parent
      @instance = constant.new
      @name     = constant.name
    end

    def destination
      @instance.destination
    end

    def file
      File.join(@name.downcase.split("::")) + ".mote"
    end

    def template
      File.read(@parent.path(file))
    end

    def render
      Mote.parse(template, @instance).call
    end
  end

  PLAN_FILE = "plan.rb"

  attr :name

  def initialize(name)
    @name = name
  end

  def path(file)
    File.join(Dir.home, ".gn", name, file)
  end

  def load!
    file = Tempfile.new([PLAN_FILE, ".rb"])
    file.write(File.read(path(PLAN_FILE)))
    file.close

    edit(file)

    if $?.success?
      load file.path
    else
      exit 1
    end
  end

  def editor
    ENV["EDITOR"] || "vi"
  end

  def edit(file)
    system "%s %s" % [editor, file.path]
  end

  def blueprints
    Plan.constants.map do |constant|
      Blueprint.new(self, Plan.const_get(constant))
    end
  end
end

module CLI
  GN_HOME = File.join(Dir.home, ".gn")

  # Display the README message and exit.
  def self.help
    puts DATA.read
  end

  # List the available templates.
  def self.list
    exec "ls -1 #{GN_HOME}"
  end

  # Install the template in the home directory.
  def self.install(template)

    # Create directory for templates if it doesn't exist.
    FileUtils.mkdir_p(GN_HOME)

    # Clone the template repository.
    Dir.chdir(GN_HOME) do
      exec "git clone %s" % template
    end
  end
end

# Continue only if the script is being executed
if $0 == __FILE__

  # Display the README if there are no arguments.
  if ARGV.empty?
    CLI.help
  else
    rest = Clap.run ARGV,
      "-h"      => CLI.method(:help),
      "--help"  => CLI.method(:help),
      "-l"      => CLI.method(:list),
      "--list"  => CLI.method(:list)

    rest = Clap.run rest,
      "-i"        => CLI.method(:install),
      "--install" => CLI.method(:install)

    rest.each do |name|
      gn = Gn.new(name)

      # Load edited plan.
      gn.load!

      # Process each blueprint.
      gn.blueprints.each do |blueprint|

        # Create destination directory.
        FileUtils.mkdir_p(File.dirname(blueprint.destination))

        # Write generated template.
        File.open(blueprint.destination, "w") do |file|
          file.write blueprint.render
        end

        # Report the file destination.
        puts "Created #{blueprint.destination}"
      end
    end
  end
end

__END__
GN(1)

NAME
      gn -- The simplest template generator.

SYNOPSIS
      gn <plan>
      gn -i <plan-url>
      gn -l
      gn -h

DESCRIPTION
      <plan>
          Opens the blueprints with the default editor, and once saved
          it expands the templates.

      -i <plan-url>
          Installs the given plan from a git repository. It clones the
          repository to ~/.gn/<plan>.

      -l
          Lists the installed templates.

      -h
          Display this help message.

EXAMPLE PLAN
      A plan is a directory in ~/.gn/<plan>, with the following
      structure:

          ~/.gn/<plan>/plan.rb
          ~/.gn/<plan>/plan/<template>.mote

      For example, consider a plan for generating a gemspec file.

          ~/.gn/gemspec/plan.rb
          ~/.gn/gemspec/plan/gemspec.mote

      The plan definition `plan.rb` has this format:

          module Plan
            class GemSpec
              def name
                "foo"
              end

              def version
                "0.0.1"
              end

              def description
                "Description of my gem"
              end

              def authors
                ["My Name"]
              end

              def email
                ["my_name@example.com"]
              end

              def homepage
                "http://example.com/"
              end

              def license
                "MIT"
              end

              def destination
                "#{name}.gemspec"
              end
            end
          end

      The only mandatory method is `destination`. Everything else is
      optional and is based on how the template is designed.

      Templates are rendered using mote (http://soveran.github.com/mote),
      the minimalist template engine. Variable interpolation is
      done by using the {{variable}} syntax, as shown in the example
      below. Variable names are extracted from the plan context, in this
      case an instance of `Plan::GemSpec`.

          # encoding: utf-8

          Gem::Specification.new do |s|
            s.name              = "{{name}}"
            s.version           = "{{version}}"
            s.summary           = "{{description}}"
            s.description       = "{{description}}"
            s.authors           = {{authors.inspect}}
            s.email             = {{email.inspect}}
            s.homepage          = "{{homepage}}"
            s.files             = []
            s.license           = "{{license}}"
            # s.executables.push(<executable>)
            # s.add_dependency <dependency>, <version>
          end

      Refer to the advanced example for information about how to
      generate different files and directory structures.

ADVANCED EXAMPLE
      It is possible to use gn to generate several files and even
      complex directory structures. Consider this plan definition:

          $ find .gn/foo
          .gn/foo//plan.rb
          .gn/foo//plan/foo.mote
          .gn/foo//plan/bar/baz.mote

          $ cat plan.rb
          module Plan
            class Foo
              def destination
                "foo.rb"
              end
            end

            module Bar
              class Bar
                def destination
                  "bar/baz.rb"
                end
              end
            end
          end

DSL USAGE
      Define your plan like this:

          require 'gn/dsl'

          module Plan
            extend Gn::DSL

            template "App", "app.rb"
          end

      Or you can provide additional methods in a block:

          require 'gn/dsl'

          module Plan
            extend Gn::DSL

            template "App", "app.rb" do
              def name
                "My App Name"
              end
            end
          end

EDITING A PLAN
      When using a template, gn gives you the ability to edit the plan
      before running it. Only the templates that correspond to classes
      defined in the Plan module get expanded and written. It means
      that if you want to create only the file `foo.rb` in the example
      above, all you have to do is delete the Bar module from the plan
      definition.

HISTORY
      In software development, there's usually the need to generate
      code or directory structures, and many tools have this feature
      built in. The idea with gn is to provide a small and simple tool
      that generalizes the task of template expansion in a way that's
      easy to understand, yet powerful and flexible.
